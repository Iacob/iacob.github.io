
#+TITLE: CQRS的实现
#+STARTUP: showeverything
#+OPTIONS: toc:nil
#+AUTHOR:

[[./index.html][回到首页]]

* 起因

许多情况下，在某个系统中读操作的次数是远大于写操作的，例如电商网站，对商品信息的读取次数远大于在网站上建立订单的次数，这时通常会将读操作与写操作分开处理，这么做的目的是
 * 优化读操作，只要优化了读操作，整个系统的工作效率就会大幅提升
 * 写操作通常很慢，我们不希望它影响频率很高的读操作，所以将其单独处理

* 结构

通常分为主控端(master)和多个代理节点(agency)，主控端和每个代理节点都有自己的存储空间(数据库)

* 各部分职责

主控端: 消息分发，执行重要的写操作

代理端: 向客户端提供数据，处理不重要的写操作，向主控端发送信息，将写操作提交给主控端处理

* 数据同步方式

数据在主控端和各个节点之间通常通过“声明与确认”的方式传输，主控端将数据库变更广播出去，各个节点自行从主控端获取数据并保存

也可由主控端直接发送数据原文，但这种方式有造成网络堵塞的风险，所以不推荐使用。

* 结论

CQRS是一种利用有限的资源和预算实现高负载系统的方式，且不会和组建集群一样需要大量的商业软件，定制的余地较大。

#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

(package-initialize)
#+END_SRC

然后打开emacs，安装软件

#+BEGIN_SRC emacs-lisp
M-x package-install
Install package: cider
#+END_SRC



[[./index.html][回到首页]]
